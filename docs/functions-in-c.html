<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/ee4aa117f8f21fdb.css" as="style"/><link rel="stylesheet" href="/_next/static/css/ee4aa117f8f21fdb.css" data-n-g=""/><link rel="preload" href="/_next/static/css/8c645c3f8152ad42.css" as="style"/><link rel="stylesheet" href="/_next/static/css/8c645c3f8152ad42.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-69bfa6990bb9e155.js" defer=""></script><script src="/_next/static/chunks/framework-00b57966872fc495.js" defer=""></script><script src="/_next/static/chunks/main-f4ae3437c92c1efc.js" defer=""></script><script src="/_next/static/chunks/pages/_app-617f4b339c1ead18.js" defer=""></script><script src="/_next/static/chunks/pages/%5B...note%5D-b1268bb9335dea2b.js" defer=""></script><script src="/_next/static/aZ_KdPSNnH8jou0WMjNFI/_buildManifest.js" defer=""></script><script src="/_next/static/aZ_KdPSNnH8jou0WMjNFI/_ssgManifest.js" defer=""></script><script src="/_next/static/aZ_KdPSNnH8jou0WMjNFI/_middlewareManifest.js" defer=""></script></head><body><div id="__next"><div class="Note_content__5LYnN"><div class="Note_content-inner__QZhed"><h1>Functions in C</h1><div class="Note_markdown__HrFl4"><p>Some predefined functions have been the <a href="math-functions-in-c">Math Functions in C</a> and <a href="file-io-in-c">File IO in C</a> functions</p>
<p>Custom functions can be defined in C to modularize programs:</p>
<pre><code class="language-c">int func(int a, int b) {
	return a + b;
}
</code></pre>
<p>Function parameters and return values receive and send back information to/from functions</p>
<blockquote>
<p>Sometimes, a function with no arguments can be written as <code>func(void)</code>, or just <code>func()</code></p>
</blockquote>
<h1>Passing by Value</h1>
<p>Primitive (<a href="variables-and-types-in-c">Variables and Types in C</a>) data types are <strong>passed by value</strong>, meaning that a copy of the value is given to the function</p>
<blockquote>
<p>Therefore, it is impossible to modify the argument values themselves back in main, unless we explicitly pass by reference</p>
</blockquote>
<h1>Function Prototypes</h1>
<p>Functions typically need to appear <strong>before</strong> the <code>main</code> function to satisfy the compiler. However, we can <strong>declare</strong> the function with the <strong>function prototype</strong> in order to put the function definition after:</p>
<pre><code class="language-c">float func(int x, int y);

int main(void) {
	func();
}

float func(int x, int y) {
	return x + y;
}
</code></pre>
<blockquote>
<p>Parameter names in the function prototype are optional, but can give extra information</p>
</blockquote>
<h1>Passing by Reference</h1>
<p>For larger data types like arrays and <code>struct</code>s, we can pass a reference (pointer) to a function so the function can know where to look for data</p>
<pre><code class="language-c">#include &#x3C;stdio.h>
int total(int n[], int len) {
	int tot = 0;
	for(int i = 0; i &#x3C; len; i++) {
		tot += n[i];
	}
	return tot;
}

int main() {
	int evens[6] = {0, 2, 4, 6, 8, 10};
	printf("%d\n", total(evens, 6));
	return 0;
}
</code></pre>
<blockquote>
<p>We cannot use <code>sizeof</code> inside a function to determine array length, as <code>sizeof</code> will return the size of the pointer instead of the array (as it doesn't know this raw pointer refers to an array). This is why we also need to pass in the number of elements.</p>
</blockquote>
<p>Since arrays are passed by reference, modifying them in the function will modify the original data</p>
<p>We cannot return an array from a function, as it will cause a <strong>dangling pointer</strong>, where a pointer refers to data that doesn't exist anymore.</p>
<blockquote>
<p>Instead, we can pass in a reference to be modified by the function.</p>
</blockquote></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"mdContent":"\u003cp\u003eSome predefined functions have been the \u003ca href=\"math-functions-in-c\"\u003eMath Functions in C\u003c/a\u003e and \u003ca href=\"file-io-in-c\"\u003eFile IO in C\u003c/a\u003e functions\u003c/p\u003e\n\u003cp\u003eCustom functions can be defined in C to modularize programs:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003eint func(int a, int b) {\n\treturn a + b;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eFunction parameters and return values receive and send back information to/from functions\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eSometimes, a function with no arguments can be written as \u003ccode\u003efunc(void)\u003c/code\u003e, or just \u003ccode\u003efunc()\u003c/code\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch1\u003ePassing by Value\u003c/h1\u003e\n\u003cp\u003ePrimitive (\u003ca href=\"variables-and-types-in-c\"\u003eVariables and Types in C\u003c/a\u003e) data types are \u003cstrong\u003epassed by value\u003c/strong\u003e, meaning that a copy of the value is given to the function\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eTherefore, it is impossible to modify the argument values themselves back in main, unless we explicitly pass by reference\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch1\u003eFunction Prototypes\u003c/h1\u003e\n\u003cp\u003eFunctions typically need to appear \u003cstrong\u003ebefore\u003c/strong\u003e the \u003ccode\u003emain\u003c/code\u003e function to satisfy the compiler. However, we can \u003cstrong\u003edeclare\u003c/strong\u003e the function with the \u003cstrong\u003efunction prototype\u003c/strong\u003e in order to put the function definition after:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003efloat func(int x, int y);\n\nint main(void) {\n\tfunc();\n}\n\nfloat func(int x, int y) {\n\treturn x + y;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003eParameter names in the function prototype are optional, but can give extra information\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch1\u003ePassing by Reference\u003c/h1\u003e\n\u003cp\u003eFor larger data types like arrays and \u003ccode\u003estruct\u003c/code\u003es, we can pass a reference (pointer) to a function so the function can know where to look for data\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003e#include \u0026#x3C;stdio.h\u003e\nint total(int n[], int len) {\n\tint tot = 0;\n\tfor(int i = 0; i \u0026#x3C; len; i++) {\n\t\ttot += n[i];\n\t}\n\treturn tot;\n}\n\nint main() {\n\tint evens[6] = {0, 2, 4, 6, 8, 10};\n\tprintf(\"%d\\n\", total(evens, 6));\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003eWe cannot use \u003ccode\u003esizeof\u003c/code\u003e inside a function to determine array length, as \u003ccode\u003esizeof\u003c/code\u003e will return the size of the pointer instead of the array (as it doesn't know this raw pointer refers to an array). This is why we also need to pass in the number of elements.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eSince arrays are passed by reference, modifying them in the function will modify the original data\u003c/p\u003e\n\u003cp\u003eWe cannot return an array from a function, as it will cause a \u003cstrong\u003edangling pointer\u003c/strong\u003e, where a pointer refers to data that doesn't exist anymore.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eInstead, we can pass in a reference to be modified by the function.\u003c/p\u003e\n\u003c/blockquote\u003e","pageTitle":"Functions in C"},"__N_SSG":true},"page":"/[...note]","query":{"note":["functions-in-c"]},"buildId":"aZ_KdPSNnH8jou0WMjNFI","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>