<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/ee4aa117f8f21fdb.css" as="style"/><link rel="stylesheet" href="/_next/static/css/ee4aa117f8f21fdb.css" data-n-g=""/><link rel="preload" href="/_next/static/css/8c645c3f8152ad42.css" as="style"/><link rel="stylesheet" href="/_next/static/css/8c645c3f8152ad42.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-69bfa6990bb9e155.js" defer=""></script><script src="/_next/static/chunks/framework-00b57966872fc495.js" defer=""></script><script src="/_next/static/chunks/main-f4ae3437c92c1efc.js" defer=""></script><script src="/_next/static/chunks/pages/_app-617f4b339c1ead18.js" defer=""></script><script src="/_next/static/chunks/pages/%5B...note%5D-b1268bb9335dea2b.js" defer=""></script><script src="/_next/static/98zXSPeJtIWDh5t6qQOx5/_buildManifest.js" defer=""></script><script src="/_next/static/98zXSPeJtIWDh5t6qQOx5/_ssgManifest.js" defer=""></script><script src="/_next/static/98zXSPeJtIWDh5t6qQOx5/_middlewareManifest.js" defer=""></script></head><body><div id="__next"><div class="Note_content__5LYnN"><div class="Note_content-inner__QZhed"><h1>Determinant by Row Operations</h1><div class="Note_markdown__HrFl4"><p>Based on the <a href="properties-of-determinants">Properties of Determinants</a>, we know what happens to the determinant of a matrix based on what row operations are applied to it</p>
<p>Therefore, if transform a matrix with elementary row operations into triangular form, we can find the determinant and "backtrack" our steps to find the determinant of the original matrix</p>
<p>Row replacements do nothing, so no "backtracking" is required</p>
<p>Negation is "reversible" so negate the matrix as many times as how many row swaps you do</p>
<p>However, scalar multiplication is not commutative, so the new determinant will be <strong>multiplied</strong> by whatever you multiply the row by</p>
<p>So to recover the original determinant, <strong>divide</strong> by that scalar</p>
<div class="math math-display"><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -0.452ex;" xmlns="http://www.w3.org/2000/svg" width="726.244ex" height="2.149ex" role="img" focusable="false" viewBox="0 -750 321000 950" xmlns:xlink="http://www.w3.org/1999/xlink"><defs></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="merror" data-mjx-error="Misplaced &#x26;" title="Misplaced &#x26;"><rect data-background="true" width="321000" height="950" y="-200"></rect><title>Misplaced &#x26;</title><g data-mml-node="mtext" style="font-family: serif"><text data-variant="-explicitFont" transform="scale(1,-1)" font-size="884px">ka &#x26; kb \\ c &#x26; d  \end{matrix}\right|$$ Therefore, if $\det B$ is the determinant of the triangular matrix, we need to **divide** by $k$ to get the original determinant  However, since all we need is the triangular (or echelon) form, there should be no scalar multiplication necessary - only row addition and row swaps  Which leads to this general method, assuming the matrix is invertible:  $$\det{A} = (-1)^r(product \ of \ pivots \ in \ U)$$  Where $U$ is the upper triangular matrix and $r$ is the number of row interchanges needed</text></g></g></g></g></svg></mjx-container></div><style>
mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
  min-height: 1px;
  min-width: 1px;
}

mjx-container[jax="SVG"] > svg a {
  fill: blue;
  stroke: blue;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][display="true"][width="full"] {
  display: flex;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line], svg[data-table] > g > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame], svg[data-table] > g > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed, svg[data-table] > g > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted, svg[data-table] > g > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > g > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

mjx-container[jax="SVG"] path[data-c], mjx-container[jax="SVG"] use[data-c] {
  stroke-width: 3;
}
</style></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"mdContent":"\u003cp\u003eBased on the \u003ca href=\"properties-of-determinants\"\u003eProperties of Determinants\u003c/a\u003e, we know what happens to the determinant of a matrix based on what row operations are applied to it\u003c/p\u003e\n\u003cp\u003eTherefore, if transform a matrix with elementary row operations into triangular form, we can find the determinant and \"backtrack\" our steps to find the determinant of the original matrix\u003c/p\u003e\n\u003cp\u003eRow replacements do nothing, so no \"backtracking\" is required\u003c/p\u003e\n\u003cp\u003eNegation is \"reversible\" so negate the matrix as many times as how many row swaps you do\u003c/p\u003e\n\u003cp\u003eHowever, scalar multiplication is not commutative, so the new determinant will be \u003cstrong\u003emultiplied\u003c/strong\u003e by whatever you multiply the row by\u003c/p\u003e\n\u003cp\u003eSo to recover the original determinant, \u003cstrong\u003edivide\u003c/strong\u003e by that scalar\u003c/p\u003e\n\u003cdiv class=\"math math-display\"\u003e\u003cmjx-container class=\"MathJax\" jax=\"SVG\" display=\"true\"\u003e\u003csvg style=\"vertical-align: -0.452ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"726.244ex\" height=\"2.149ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -750 321000 950\" xmlns:xlink=\"http://www.w3.org/1999/xlink\"\u003e\u003cdefs\u003e\u003c/defs\u003e\u003cg stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"\u003e\u003cg data-mml-node=\"math\"\u003e\u003cg data-mml-node=\"merror\" data-mjx-error=\"Misplaced \u0026#x26;\" title=\"Misplaced \u0026#x26;\"\u003e\u003crect data-background=\"true\" width=\"321000\" height=\"950\" y=\"-200\"\u003e\u003c/rect\u003e\u003ctitle\u003eMisplaced \u0026#x26;\u003c/title\u003e\u003cg data-mml-node=\"mtext\" style=\"font-family: serif\"\u003e\u003ctext data-variant=\"-explicitFont\" transform=\"scale(1,-1)\" font-size=\"884px\"\u003eka \u0026#x26; kb \\\\ c \u0026#x26; d  \\end{matrix}\\right|$$ Therefore, if $\\det B$ is the determinant of the triangular matrix, we need to **divide** by $k$ to get the original determinant  However, since all we need is the triangular (or echelon) form, there should be no scalar multiplication necessary - only row addition and row swaps  Which leads to this general method, assuming the matrix is invertible:  $$\\det{A} = (-1)^r(product \\ of \\ pivots \\ in \\ U)$$  Where $U$ is the upper triangular matrix and $r$ is the number of row interchanges needed\u003c/text\u003e\u003c/g\u003e\u003c/g\u003e\u003c/g\u003e\u003c/g\u003e\u003c/svg\u003e\u003c/mjx-container\u003e\u003c/div\u003e\u003cstyle\u003e\nmjx-container[jax=\"SVG\"] {\n  direction: ltr;\n}\n\nmjx-container[jax=\"SVG\"] \u003e svg {\n  overflow: visible;\n  min-height: 1px;\n  min-width: 1px;\n}\n\nmjx-container[jax=\"SVG\"] \u003e svg a {\n  fill: blue;\n  stroke: blue;\n}\n\nmjx-container[jax=\"SVG\"][display=\"true\"] {\n  display: block;\n  text-align: center;\n  margin: 1em 0;\n}\n\nmjx-container[jax=\"SVG\"][display=\"true\"][width=\"full\"] {\n  display: flex;\n}\n\nmjx-container[jax=\"SVG\"][justify=\"left\"] {\n  text-align: left;\n}\n\nmjx-container[jax=\"SVG\"][justify=\"right\"] {\n  text-align: right;\n}\n\ng[data-mml-node=\"merror\"] \u003e g {\n  fill: red;\n  stroke: red;\n}\n\ng[data-mml-node=\"merror\"] \u003e rect[data-background] {\n  fill: yellow;\n  stroke: none;\n}\n\ng[data-mml-node=\"mtable\"] \u003e line[data-line], svg[data-table] \u003e g \u003e line[data-line] {\n  stroke-width: 70px;\n  fill: none;\n}\n\ng[data-mml-node=\"mtable\"] \u003e rect[data-frame], svg[data-table] \u003e g \u003e rect[data-frame] {\n  stroke-width: 70px;\n  fill: none;\n}\n\ng[data-mml-node=\"mtable\"] \u003e .mjx-dashed, svg[data-table] \u003e g \u003e .mjx-dashed {\n  stroke-dasharray: 140;\n}\n\ng[data-mml-node=\"mtable\"] \u003e .mjx-dotted, svg[data-table] \u003e g \u003e .mjx-dotted {\n  stroke-linecap: round;\n  stroke-dasharray: 0,140;\n}\n\ng[data-mml-node=\"mtable\"] \u003e g \u003e svg {\n  overflow: visible;\n}\n\n[jax=\"SVG\"] mjx-tool {\n  display: inline-block;\n  position: relative;\n  width: 0;\n  height: 0;\n}\n\n[jax=\"SVG\"] mjx-tool \u003e mjx-tip {\n  position: absolute;\n  top: 0;\n  left: 0;\n}\n\nmjx-tool \u003e mjx-tip {\n  display: inline-block;\n  padding: .2em;\n  border: 1px solid #888;\n  font-size: 70%;\n  background-color: #F8F8F8;\n  color: black;\n  box-shadow: 2px 2px 5px #AAAAAA;\n}\n\ng[data-mml-node=\"maction\"][data-toggle] {\n  cursor: pointer;\n}\n\nmjx-status {\n  display: block;\n  position: fixed;\n  left: 1em;\n  bottom: 1em;\n  min-width: 25%;\n  padding: .2em .4em;\n  border: 1px solid #888;\n  font-size: 90%;\n  background-color: #F8F8F8;\n  color: black;\n}\n\nforeignObject[data-mjx-xml] {\n  font-family: initial;\n  line-height: normal;\n  overflow: visible;\n}\n\nmjx-container[jax=\"SVG\"] path[data-c], mjx-container[jax=\"SVG\"] use[data-c] {\n  stroke-width: 3;\n}\n\u003c/style\u003e","pageTitle":"Determinant by Row Operations"},"__N_SSG":true},"page":"/[...note]","query":{"note":["determinant-by-row-operations"]},"buildId":"98zXSPeJtIWDh5t6qQOx5","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>